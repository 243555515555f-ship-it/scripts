-- Menoo GeminiLib V6
local GeminiLib = loadstring(game:HttpGet("https://raw.githubusercontent.com/243555515555f-ship-it/scripts/refs/heads/main/GeminiLib%20V6"))()

-- Services & cached locals
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local GuiService = game:GetService("GuiService")
local Workspace = game:GetService("Workspace")
local Lighting = game:GetService("Lighting")

local player = Players.LocalPlayer
local Camera = Workspace.CurrentCamera

-- Character references (kept current)
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:FindFirstChildOfClass("Humanoid")
local rootPart = character:FindFirstChild("HumanoidRootPart")

local function refreshCharacterRefs()
    character = player.Character or player.CharacterAdded:Wait()
    humanoid = character and character:FindFirstChildOfClass("Humanoid")
    rootPart = character and character:FindFirstChild("HumanoidRootPart")
end

local connections = {}

player.CharacterAdded:Connect(function()
    task.wait(0.1)
    refreshCharacterRefs()
end)

-- Utility getters (safer)
local function getPlayerObject()
    return player.Character or workspace:FindFirstChild(player.Name)
end

local function getPlayerHumanoid()
    local p = getPlayerObject()
    return p and p:FindFirstChildOfClass("Humanoid")
end

local function getRootPart()
    local p = getPlayerObject()
    return p and p:FindFirstChild("HumanoidRootPart")
end


local function Notify(text, duration)
    GeminiLib:CreateNotification({
        Title = "Menoo " .. GeminiLib:Version(),
        Text = text,
        Duration = duration or 5
    })
end

local currentTheme = "Cyberpunk"
local MenooWindow = GeminiLib:CreateWindow("Menoo", currentTheme)

local PlrBypassTab = MenooWindow:CreateTab("Player Bypass", "üéÖ")
local ESPTab = MenooWindow:CreateTab("ESP Tools", "üéá")
local XrayTab = MenooWindow:CreateTab("Xray Tools", "üéÑ")
local GameSpecificTab = MenooWindow:CreateTab("Game Specific Tools", "üéÑ")
local MasterFuncTab = MenooWindow:CreateTab("Master Functions", "üéá")
local OtherToolsTab = MenooWindow:CreateTab("Other Tools", "üßë‚ÄçüéÑ")
local SettingsTab = MenooWindow:CreateTab("Settings", "üéá")
local CreditsTab = MenooWindow:CreateTab("Credits", "üéÅ")


local oldWalkSpeed = getPlayerHumanoid().WalkSpeed
local oldJumpPower = getPlayerHumanoid().JumpPower
local newWalkSpeed = 0
local newJumpPower = 0


------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PlrBypassTab:Label("Player Bypass Features ‚ôæÔ∏é")

PlrBypassTab:Slider("WalkSpeed Bypass Value", oldWalkSpeed, 200, oldWalkSpeed, function(value)
    newWalkSpeed = value
end, oldWalkSpeed)

PlrBypassTab:Toggle("Enable WalkSpeed Bypass", false, function(state)
    local plr = getPlayerHumanoid()
    if state then
        plr.WalkSpeed = newWalkSpeed
    else
        plr.WalkSpeed = oldWalkSpeed
    end
end)


------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PlrBypassTab:Label("Jump Bypass Features ‚õ∑")

PlrBypassTab:Button("Jump Enable Bypass (If dont work)", function()
    local plr = getPlayerHumanoid()
    plr.UseJumpPower = true
    plr.AutoJumpEnabled = true
end, "")
PlrBypassTab:Slider("JumpPower Bypass Value", oldJumpPower, 350, oldJumpPower, function(value)
    newJumpPower = value
end, oldJumpPower)
PlrBypassTab:Toggle("JumpPower On/Off", false, function(state)
    if state then
        local plr = getPlayerHumanoid()
        plr.JumpPower = newJumpPower
    else
        local plr = getPlayerHumanoid()
        plr.JumpPower = oldJumpPower
    end
end, "")


------------------------------------------------------------------------------------------------------------------------------------------------------------------------
local CAS = game:GetService("ContextActionService")
local ACTION_NAME = "DisableCtrlGameBind"

PlrBypassTab:Label("Fly Tools (WASD, SPACE, LEFT CTRL) ‚úà")

local function DisableGameControl()
    CAS:BindActionAtPriority(
        ACTION_NAME,
        function(actionName, inputState, inputObject)
            -- –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–∞–∂–∞–ª –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∫–Ω–æ–ø–∫—É –∏–ª–∏ –æ—Ç–ø—É—Å—Ç–∏–ª
            if inputState == Enum.UserInputState.Begin then
                _G.FlyDownActive = true  -- –í–∫–ª—é—á–∞–µ–º —Ñ–ª–∞–≥ –¥–≤–∏–∂–µ–Ω–∏—è –≤–Ω–∏–∑
            elseif inputState == Enum.UserInputState.End then
                _G.FlyDownActive = false -- –í—ã–∫–ª—é—á–∞–µ–º —Ñ–ª–∞–≥
            end
            
            -- –í–æ–∑–≤—Ä–∞—â–∞–µ–º Sink, —á—Ç–æ–±—ã –∏–≥—Ä–∞ (Blox Fruits –∏ –¥—Ä.) –Ω–µ –≤–∏–¥–µ–ª–∞ Ctrl
            return Enum.ContextActionResult.Sink
        end,
        false, 
        Enum.ContextActionPriority.High.Value + 1000, 
        Enum.KeyCode.LeftControl,
        Enum.KeyCode.RightControl
    )
end
local function EnableGameControl()
    _G.FlyDownActive = false
    CAS:UnbindAction(ACTION_NAME)
end



local Flight = {
    Enabled = false,
    Speed = 50,
    VerticalUp = false,
    VerticalDown = false,
    Connection = nil,
    ForceName = "FlightForce_" .. math.random(100, 999)
}

local KeyState = {W = 0, S = 0, A = 0, D = 0}

-- 1. –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –≤–≤–æ–¥
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    local kc = input.KeyCode
    if KeyState[kc.Name] ~= nil then KeyState[kc.Name] = 1 end
    if kc == Enum.KeyCode.Space then Flight.VerticalUp = true end
    if kc == Enum.KeyCode.LeftControl then Flight.VerticalDown = true end
end)

UserInputService.InputEnded:Connect(function(input)
    local kc = input.KeyCode
    if KeyState[kc.Name] ~= nil then KeyState[kc.Name] = 0 end
    if kc == Enum.KeyCode.Space then Flight.VerticalUp = false end
    if kc == Enum.KeyCode.LeftControl then Flight.VerticalDown = false end
end)

-- 2. –Ø–¥—Ä–æ –ø–æ–ª–µ—Ç–∞
local function flightUpdate()
    if not Flight.Enabled then return end
    local rp = getRootPart()
    local hum = getPlayerHumanoid()
    if not rp or not hum then return end

    local cam = workspace.CurrentCamera
    local cf = cam.CFrame
    
    local moveDir = Vector3.new(0, 0, 0)
    local vertical = (Flight.VerticalUp and 1 or 0) - (Flight.VerticalDown and 1 or 0)

    if UserInputService.TouchEnabled then
        -- Mobile: –±–µ—Ä–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–∂–æ–π—Å—Ç–∏–∫–∞
        local joyDir = hum.MoveDirection
        if joyDir.Magnitude > 0.05 then
            -- –ï—Å–ª–∏ —Ç—è–Ω–µ–º –¥–∂–æ–π—Å—Ç–∏–∫, –ª–µ—Ç–∏–º —Ç—É–¥–∞, –∫—É–¥–∞ —Å–º–æ—Ç—Ä–∏—Ç –∫–∞–º–µ—Ä–∞
            moveDir = cf:VectorToWorldSpace(Vector3.new(joyDir.X, 0, -joyDir.Z).Unit)
            -- –ù–∞–∫–ª–æ–Ω –∫–∞–º–µ—Ä—ã –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç –≤—ã—Å–æ—Ç—É (–Ω–∞ –º–æ–±–∏–ª–∫–∞—Ö —ç—Ç–æ —É–¥–æ–±–Ω–µ–µ)
            moveDir = (moveDir + Vector3.new(0, cf.LookVector.Y * 1.5, 0)).Unit
        end
    else
        -- PC: –†–∞—Å—á–µ—Ç WASD
        local forward = (KeyState.W - KeyState.S)
        local side = (KeyState.D - KeyState.A)
        
        -- –î–≤–∏–∂–µ–Ω–∏–µ –ø–æ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ XZ
        local camXZ = Vector3.new(cf.LookVector.X, 0, cf.LookVector.Z).Unit
        local camRightXZ = Vector3.new(cf.RightVector.X, 0, cf.RightVector.Z).Unit
        
        moveDir = (camXZ * forward + camRightXZ * side)
        if moveDir.Magnitude > 0 then moveDir = moveDir.Unit end
    end

    -- –ü—Ä–∏–º–µ–Ω—è–µ–º —Å–∫–æ—Ä–æ—Å—Ç—å
    local force = rp:FindFirstChild(Flight.ForceName)
    if force then
        force.Velocity = (moveDir * Flight.Speed) + Vector3.new(0, vertical * Flight.Speed, 0)
    end
end

-- 3. –ó–∞–ø—É—Å–∫ –∏ –û—Å—Ç–∞–Ω–æ–≤–∫–∞
local function startFlight()
    if Flight.Enabled then return end
    Flight.Enabled = true
    local rp = getRootPart()
    if not rp then return end

    local bv = Instance.new("BodyVelocity")
    bv.Name = Flight.ForceName
    bv.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
    bv.Velocity = Vector3.new(0, 0, 0)
    bv.Parent = rp

    Flight.Connection = RunService.Heartbeat:Connect(flightUpdate)
    getPlayerHumanoid().PlatformStand = true
end

local function stopFlight()
    Flight.Enabled = false
    if Flight.Connection then Flight.Connection:Disconnect() end
    local rp = getRootPart()
    local bv = rp and rp:FindFirstChild(Flight.ForceName)
    if bv then bv:Destroy() end
    getPlayerHumanoid().PlatformStand = false
end

PlrBypassTab:Slider("Fly Speed", 10, 500, 50,
    function(value)
        Flight.Speed = value
    end
)

PlrBypassTab:Toggle("Fly On/Off", false,
    function(state)
        if state then
            DisableGameControl()
            startFlight()
        else
            EnableGameControl()
            stopFlight()
        end
    end
)



------------------------------------------------------------------------------------------------------------------------------------------------------------------------
PlrBypassTab:Label("Strange Func")
local Noclip = { Enabled = false, Conn = nil }
PlrBypassTab:Toggle("NoClip On/Off", false,
    function(on)
        if on then
            if Noclip.Conn then Noclip.Conn:Disconnect() end
            Noclip.Conn = RunService.Stepped:Connect(function()
                local p = getPlayerObject()
                if p then
                    for _, part in ipairs(p:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                end
            end)
            Noclip.Enabled = true
        else
            if Noclip.Conn then Noclip.Conn:Disconnect() Noclip.Conn = nil end
            local p = getPlayerObject()
            if p then
                for _, part in ipairs(p:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end
            Noclip.Enabled = false
        end
    end
)
local God = { Enabled = false, Conn = nil }
PlrBypassTab:Toggle("Godmode On/Off", false, function(state)
    local h = getPlayerHumanoid()
    if state then
        if h then
            if God.Conn then God.Conn:Disconnect() end
            God.Conn = h.HealthChanged:Connect(function()
                if h and h.Health < 0.5 then
                    h.Health = h.MaxHealth or 100
                 end
            end)
            God.Enabled = true
        end
    else
        if God.Conn then God.Conn:Disconnect() God.Conn = nil end
        if h then h.Health = h.MaxHealth or 100 end
        God.Enabled = false
    end
end)

-- Invisible Bypass
local PlayerValue = {} do
	local mouseBehavior = ""
	local mouseIconEnabled = ""
	local cameraType = ""
	local cameraFocus = ""
	local cameraCFrame = ""
	local cameraFieldOfView = ""

	function PlayerValue.Push()
		cameraFieldOfView = Camera.FieldOfView
		Camera.FieldOfView = 70

		cameraType = Camera.CameraType
		Camera.CameraType = Enum.CameraType.Custom

		cameraCFrame = Camera.CFrame
		cameraFocus = Camera.Focus

		mouseIconEnabled = UserInputService.MouseIconEnabled
		UserInputService.MouseIconEnabled = true

		mouseBehavior = UserInputService.MouseBehavior
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	end

	function PlayerValue.Pop()
		Camera.FieldOfView = 70

		Camera.CameraType = cameraType
		cameraType = nil

		Camera.CFrame = cameraCFrame
		cameraCFrame = nil

		Camera.Focus = cameraFocus
		cameraFocus = nil

		UserInputService.MouseIconEnabled = mouseIconEnabled
		mouseIconEnabled = nil

		UserInputService.MouseBehavior = mouseBehavior
		mouseBehavior = nil
	end
end
function StopFreecam()
    local fcRunning = false
	if not fcRunning then return end
	RunService:UnbindFromRenderStep("Freecam")
	PlayerValue.Pop()
	Workspace.Camera.FieldOfView = 70
	fcRunning = false
end

local viewing = nil
local viewDied = nil
local viewChanged = nil

function fixcam()
    StopFreecam()
    if viewing ~= nil then
        viewing = nil
    end
    if viewDied then
        viewDied:Disconnect()
        viewChanged:Disconnect()
    end
    
    if player.Character and player.Character:FindFirstChildWhichIsA('Humanoid') then
        Workspace.CurrentCamera.CameraSubject = player.Character:FindFirstChildWhichIsA('Humanoid')
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
    end
    
    player.CameraMinZoomDistance = 0.5
    player.CameraMaxZoomDistance = 400
    player.CameraMode = "Classic"
    
    if player.Character and player.Character:FindFirstChild("Head") then
        player.Character.Head.Anchored = false
    end
end

local invisRunning = false
local Invisible = { Enabled = false, Conn = nil, TurnVisibleFunc = nil, invisFix = nil, invisDied = nil, InvisibleCharacter = nil, OriginalCharacter = nil }

PlrBypassTab:Toggle("Invisible On/Off", false, function(state)
    if state then
        -- TURN INVISIBLE
        if invisRunning then return end
        invisRunning = true
        repeat task.wait(.1) until player.Character
        local Character = player.Character
        Character.Archivable = true
        local IsInvis = false
        local InvisibleCharacter = Character:Clone()
        InvisibleCharacter.Parent = Lighting
        local Void = Workspace.FallenPartsDestroyHeight

        InvisibleCharacter.Name = ""

        -- Store references
        Invisible.InvisibleCharacter = InvisibleCharacter
        Invisible.OriginalCharacter = Character

        Invisible.invisFix = RunService.Stepped:Connect(function()
            pcall(function()
                if not player.Character or not player.Character:FindFirstChild("HumanoidRootPart") then return end
                local IsInteger = tostring(Void):find('-') and true or false
                local Pos = player.Character.HumanoidRootPart.Position
                local Pos_String = tostring(Pos)
                local Pos_Seperate = Pos_String:split(', ')
                local Y = tonumber(Pos_Seperate[2])
                if (IsInteger and Y <= Void) or (not IsInteger and Y >= Void) then
                    Invisible.TurnVisibleFunc()
                end
            end)
        end)

        for i,v in pairs(InvisibleCharacter:GetDescendants()) do
            if v:IsA("BasePart") then
                if v.Name == "HumanoidRootPart" then
                    v.Transparency = 1
                else
                    v.Transparency = .5
                end
            end
        end

        Invisible.invisDied = InvisibleCharacter:FindFirstChildOfClass'Humanoid'.Died:Connect(function()
            if Invisible.TurnVisibleFunc then
                Invisible.TurnVisibleFunc()
            end
        end)

        function Invisible.TurnVisibleFunc()
            if not invisRunning then return end
            invisRunning = false
            Invisible.Enabled = false

            pcall(function()
                if Invisible.invisFix then
                    Invisible.invisFix:Disconnect()
                    Invisible.invisFix = nil
                end
                if Invisible.invisDied then
                    Invisible.invisDied:Disconnect()
                    Invisible.invisDied = nil
                end

                -- destroy the invisible clone
                if Invisible.InvisibleCharacter and Invisible.InvisibleCharacter.Parent then
                    Invisible.InvisibleCharacter:Destroy()
                    Invisible.InvisibleCharacter = nil
                end

                if Invisible.OriginalCharacter then
                    local visibleHRP = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
                    local targetCFrame = visibleHRP and visibleHRP.CFrame or (Invisible.OriginalCharacter:FindFirstChild("HumanoidRootPart") and Invisible.OriginalCharacter.HumanoidRootPart.CFrame)

                    Invisible.OriginalCharacter.Parent = Workspace

                    local origHRP = Invisible.OriginalCharacter:FindFirstChild("HumanoidRootPart") or Invisible.OriginalCharacter:WaitForChild("HumanoidRootPart", 1)
                    local humanoid = Invisible.OriginalCharacter:FindFirstChildOfClass("Humanoid")

                    origHRP.CFrame = targetCFrame

                    for _, part in pairs(Invisible.OriginalCharacter:GetDescendants()) do
                        if part:IsA("BasePart") then
                            pcall(function()
                                part.Anchored = false
                                part.CanCollide = true
                            end)
                            for _, child in pairs(part:GetChildren()) do
                                if child:IsA("BodyVelocity") or child:IsA("BodyAngularVelocity") or child:IsA("BodyForce")
                                or child:IsA("VectorForce") or child:IsA("LinearVelocity") then
                                    pcall(child.Destroy, child)
                                end
                            end
                        end
                    end

                    if humanoid then
                        pcall(function()
                            humanoid.PlatformStand = false
                            humanoid.Sit = false
                            humanoid.WalkSpeed = (humanoid.WalkSpeed and humanoid.WalkSpeed > 0) and humanoid.WalkSpeed or 16
                            humanoid.JumpPower = (humanoid.JumpPower and humanoid.JumpPower > 0) and humanoid.JumpPower or 50
                        end)
                    end

                    player.Character = Invisible.OriginalCharacter

                    local animate = Invisible.OriginalCharacter:FindFirstChild("Animate")
                    if animate then
                        animate.Disabled = true
                        task.wait(0.05)
                        animate.Disabled = false
                    end
                end

                fixcam()
            end)
        end

        IsInvis = true
        local CF_1 = Character.HumanoidRootPart.CFrame
        Character:MoveTo(Vector3.new(0, math.pi*10000, 0))
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
        task.wait(.2)
        Workspace.CurrentCamera.CameraType = Enum.CameraType.Custom
        Character.Parent = Lighting
        InvisibleCharacter.Parent = Workspace
        InvisibleCharacter.HumanoidRootPart.CFrame = CF_1
        player.Character = InvisibleCharacter
        fixcam()
        player.Character.Animate.Disabled = true
        player.Character.Animate.Disabled = false
        Invisible.Enabled = true

    else
        -- TURN VISIBLE
        if Invisible.TurnVisibleFunc then
            Invisible.TurnVisibleFunc()
        end

    end
end)


------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ESPTab:Label("ESP Tools‚òÑ")

-- –ú–û–î–£–õ–¨ RAINBOW HIGHLIGHT ESP
local RainbowHighlightESP = {
    Enabled = false,
    Objects = {},
    Connections = {},
    RainbowLoop = nil
}

local function removeRainbowHighlightESP(player)
    if RainbowHighlightESP.Objects[player] then
        if RainbowHighlightESP.Objects[player].Highlight then 
            RainbowHighlightESP.Objects[player].Highlight:Destroy() 
        end
        RainbowHighlightESP.Objects[player] = nil
    end
end

local function applyRainbowHighlightESP(player)
    if player == Players.LocalPlayer then return end
    
    local character = player.Character
    if not character then return end
    
    local head = character:FindFirstChild("Head")
    if not head then return end
    
    removeRainbowHighlightESP(player)
    
    local highlight = Instance.new("Highlight")
    highlight.Name = "RainbowHighlightESP"
    highlight.OutlineColor = Color3.fromHSV(0, 1, 1)
    highlight.FillTransparency = 1
    highlight.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    highlight.OutlineTransparency = 0
    highlight.Parent = character
    
    RainbowHighlightESP.Objects[player] = {
        Highlight = highlight,
        Character = character
    }
    
    return highlight
end

local function manageRainbowHighlightESP(player)
    if not RainbowHighlightESP.Enabled then return end
    
    local function characterAdded()
        if not RainbowHighlightESP.Enabled then return end
        task.wait(0.5)
        applyRainbowHighlightESP(player)
    end
    
    local function characterRemoving()
        removeRainbowHighlightESP(player)
    end
    
    RainbowHighlightESP.Connections[player] = {
        Added = player.CharacterAdded:Connect(characterAdded),
        Removing = player.CharacterRemoving:Connect(characterRemoving)
    }
    
    if player.Character then
        task.spawn(characterAdded)
    end
end

local function startRainbowHighlightLoop()
    if RainbowHighlightESP.RainbowLoop then
        RainbowHighlightESP.RainbowLoop:Disconnect()
    end
    
    RainbowHighlightESP.RainbowLoop = RunService.RenderStepped:Connect(function()
        local hue = (tick() * 0.2) % 1
        local color = Color3.fromHSV(hue, 1, 1)
        
        for _, data in pairs(RainbowHighlightESP.Objects) do
            if data.Highlight and data.Highlight.Parent then
                data.Highlight.OutlineColor = color
            end
        end
    end)
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—è
local function toggleRainbowHighlightESP(state)
    RainbowHighlightESP.Enabled = state
    
    if state then
        -- –í–∫–ª—é—á–∞–µ–º
        for _, player in pairs(Players:GetPlayers()) do
            manageRainbowHighlightESP(player)
        end
        
        RainbowHighlightESP.PlayerAddedConn = Players.PlayerAdded:Connect(function(player)
            if RainbowHighlightESP.Enabled then
                manageRainbowHighlightESP(player)
            end
        end)
        
        startRainbowHighlightLoop()
        -- Notify("Rainbow Highlight ESP enabled", 5)
    else
        -- –í—ã–∫–ª—é—á–∞–µ–º
        if RainbowHighlightESP.PlayerAddedConn then
            RainbowHighlightESP.PlayerAddedConn:Disconnect()
            RainbowHighlightESP.PlayerAddedConn = nil
        end
        
        if RainbowHighlightESP.RainbowLoop then
            RainbowHighlightESP.RainbowLoop:Disconnect()
            RainbowHighlightESP.RainbowLoop = nil
        end
        
        for player, connections in pairs(RainbowHighlightESP.Connections) do
            if connections.Added then connections.Added:Disconnect() end
            if connections.Removing then connections.Removing:Disconnect() end
            removeRainbowHighlightESP(player)
        end
        
        RainbowHighlightESP.Objects = {}
        RainbowHighlightESP.Connections = {}
        -- Notify("Rainbow Highlight ESP disabled", 5)
    end
end

-- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ UI:
ESPTab:Toggle("Rainbow Highlight ESP On/Off", false, function(state)
    toggleRainbowHighlightESP(state)
end)

-------
-- –ú–û–î–£–õ–¨ RAINBOW NAME ESP
local RainbowNameESP = {
    Enabled = false,
    Objects = {},
    Connections = {},
    RainbowLoop = nil,
    PlayerAddedConn = nil
}

local function removeRainbowNameESP(player)
    if RainbowNameESP.Objects[player] then
        if RainbowNameESP.Objects[player].BillboardGui then 
            RainbowNameESP.Objects[player].BillboardGui:Destroy() 
        end
        RainbowNameESP.Objects[player] = nil
    end
end

local function createRainbowNameTag(player, character)
    local head = character:FindFirstChild("Head")
    if not head then return nil end
    
    -- –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π ESP –µ—Å–ª–∏ –µ—Å—Ç—å
    local existing = head:FindFirstChild("RainbowNameESP_Billboard")
    if existing then existing:Destroy() end
    
    local billboardGui = Instance.new("BillboardGui")
    billboardGui.Name = "RainbowNameESP_Billboard"
    billboardGui.Adornee = head
    billboardGui.Size = UDim2.new(10, 0, 3, 0)
    billboardGui.StudsOffset = Vector3.new(0, 4.5, 0)
    billboardGui.AlwaysOnTop = true
    billboardGui.MaxDistance = 600
    billboardGui.Parent = head
    
    local textLabel = Instance.new("TextLabel")
    textLabel.Name = "NameLabel"
    textLabel.Size = UDim2.new(1, 0, 1, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = player.Name
    textLabel.TextScaled = true
    textLabel.Font = Enum.Font.SourceSansBold
    textLabel.TextStrokeTransparency = 0.2
    textLabel.TextStrokeColor3 = Color3.new(0, 0, 0)
    textLabel.TextColor3 = Color3.fromHSV(0, 1, 1)
    textLabel.Parent = billboardGui
    
    return {
        BillboardGui = billboardGui,
        TextLabel = textLabel,
        Character = character
    }
end

local function applyRainbowNameESP(player)
    if player == Players.LocalPlayer then return end
    
    local character = player.Character
    if not character then return end
    
    removeRainbowNameESP(player)
    
    local nameTag = createRainbowNameTag(player, character)
    if nameTag then
        RainbowNameESP.Objects[player] = nameTag
    end
end

local function manageRainbowNameESP(player)
    if not RainbowNameESP.Enabled then return end
    
    local function characterAdded()
        if not RainbowNameESP.Enabled then return end
        task.wait(0.3)
        applyRainbowNameESP(player)
    end
    
    local function characterRemoving()
        removeRainbowNameESP(player)
    end
    
    RainbowNameESP.Connections[player] = {
        Added = player.CharacterAdded:Connect(characterAdded),
        Removing = player.CharacterRemoving:Connect(characterRemoving)
    }
    
    if player.Character then
        task.spawn(characterAdded)
    end
end

local function startRainbowNameLoop()
    if RainbowNameESP.RainbowLoop then
        RainbowNameESP.RainbowLoop:Disconnect()
    end
    
    RainbowNameESP.RainbowLoop = RunService.RenderStepped:Connect(function()
        local hue = (tick() * 0.3) % 1
        local color = Color3.fromHSV(hue, 1, 1)
        
        for _, data in pairs(RainbowNameESP.Objects) do
            if data.TextLabel and data.TextLabel.Parent then
                data.TextLabel.TextColor3 = color
            end
        end
    end)
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—è
local function toggleRainbowNameESP(state)
    RainbowNameESP.Enabled = state
    
    if state then
        -- –í–∫–ª—é—á–∞–µ–º
        for _, player in pairs(Players:GetPlayers()) do
            manageRainbowNameESP(player)
        end
        
        RainbowNameESP.PlayerAddedConn = Players.PlayerAdded:Connect(function(player)
            if RainbowNameESP.Enabled then
                manageRainbowNameESP(player)
            end
        end)
        
        RainbowNameESP.PlayerRemovingConn = Players.PlayerRemoving:Connect(function(player)
            removeRainbowNameESP(player)
        end)
        
        startRainbowNameLoop()
        -- Notify("Rainbow Name ESP enabled", 5)
    else
        -- –í—ã–∫–ª—é—á–∞–µ–º
        if RainbowNameESP.PlayerAddedConn then
            RainbowNameESP.PlayerAddedConn:Disconnect()
            RainbowNameESP.PlayerAddedConn = nil
        end
        
        if RainbowNameESP.PlayerRemovingConn then
            RainbowNameESP.PlayerRemovingConn:Disconnect()
            RainbowNameESP.PlayerRemovingConn = nil
        end
        
        if RainbowNameESP.RainbowLoop then
            RainbowNameESP.RainbowLoop:Disconnect()
            RainbowNameESP.RainbowLoop = nil
        end
        
        for player, connections in pairs(RainbowNameESP.Connections) do
            if connections.Added then connections.Added:Disconnect() end
            if connections.Removing then connections.Removing:Disconnect() end
            removeRainbowNameESP(player)
        end
        
        RainbowNameESP.Objects = {}
        RainbowNameESP.Connections = {}
        -- Notify("Rainbow Name ESP disabled", 5)
    end
end

-- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ UI:
ESPTab:Toggle("Rainbow Name ESP On/Off", false, function(state)
    toggleRainbowNameESP(state)
end)
-----------
_G.TracersEnabled = false

-- –û–±—â–∞—è —Ç–∞–±–ª–∏—Ü–∞ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –ª–∏–Ω–∏–π
local tracerLines = {}

-- –§—É–Ω–∫—Ü–∏—è –æ—á–∏—Å—Ç–∫–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –ª–∏–Ω–∏–∏
local function removeLine(player)
    if tracerLines[player] then
        tracerLines[player]:Remove()
        tracerLines[player] = nil
    end
end

-- –û—Å–Ω–æ–≤–Ω–æ–π —Ü–∏–∫–ª –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ (—Ä–∞–±–æ—Ç–∞–µ—Ç –≤—Å–µ–≥–¥–∞, –Ω–æ —Ä–∏—Å—É–µ—Ç —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ)
RunService.RenderStepped:Connect(function()
    for _, player in ipairs(Players:GetPlayers()) do
        if _G.TracersEnabled and player ~= Players.LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local rootPart = player.Character.HumanoidRootPart
            local screenPos, onScreen = Camera:WorldToViewportPoint(rootPart.Position)

            if onScreen then
                -- –ï—Å–ª–∏ –ª–∏–Ω–∏–∏ –µ—â–µ –Ω–µ—Ç ‚Äî —Å–æ–∑–¥–∞–µ–º
                if not tracerLines[player] then
                    local newLine = Drawing.new("Line")
                    newLine.Thickness = 1
                    newLine.Color = Color3.fromRGB(255, 255, 255)
                    newLine.Transparency = 0.7
                    tracerLines[player] = newLine
                end
                
                -- –û–±–Ω–æ–≤–ª—è–µ–º –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã
                local line = tracerLines[player]
                line.From = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y)
                line.To = Vector2.new(screenPos.X, screenPos.Y)
                line.Visible = true
            else
                if tracerLines[player] then tracerLines[player].Visible = false end
            end
        else
            -- –ï—Å–ª–∏ –≤—ã–∫–ª—é—á–µ–Ω–æ –∏–ª–∏ –∏–≥—Ä–æ–∫–∞ –Ω–µ—Ç ‚Äî —Å–∫—Ä—ã–≤–∞–µ–º
            if tracerLines[player] then
                tracerLines[player].Visible = false
            end
        end
    end
end)

-- –û—á–∏—Å—Ç–∫–∞ –ø—Ä–∏ –≤—ã—Ö–æ–¥–µ –∏–≥—Ä–æ–∫–∞
Players.PlayerRemoving:Connect(removeLine)

-- –¢–í–û–ô –ü–ï–†–ï–ö–õ–Æ–ß–ê–¢–ï–õ–¨
ESPTab:Toggle("Tracers ESP (Lines to Head) On/Off", false, function (State)
    _G.TracersEnabled = State
    -- –ï—Å–ª–∏ –≤—ã–∫–ª—é—á–∞–µ–º ‚Äî –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ —Å–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ –ª–∏–Ω–∏–∏ —Å—Ä–∞–∑—É
    if not State then
        for _, line in pairs(tracerLines) do
            line.Visible = false
        end
    end
end)


------------------------------------------------------------------------------------------------------------------------------------------------------------------------
XrayTab:Label("Xray ToolsìÅæìÅæ")

local xrayEnabled = false
local function xray()
    for _, v in pairs(Workspace:GetDescendants()) do
        if v:IsA("BasePart") and not v.Parent:FindFirstChildWhichIsA("Humanoid") and not v.Parent.Parent:FindFirstChildWhichIsA("Humanoid") then
            v.LocalTransparencyModifier = xrayEnabled and 0.5 or 0
        end
    end
end
XrayTab:Toggle("XRay On/Off", false,
    function(State)
        xrayEnabled = State
        if State then
            xray()
        else
            xray()
        end
    end
)

XrayTab:Button("Refresh XRay", function()
    xray()
end)

XrayTab:Label("More in future updates...")

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
GameSpecificTab:Label("Game Specific Tools‚∏ò")

local RainbowFling = { 
    Enabled = false, 
    Conn = nil,
    RainbowOffset = 0,
    Speed = 2
}

local function applyVerticalRainbow(character)
    if not character then return end
    
    local parts = {}
    
    -- –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —á–∞—Å—Ç–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
    for _, part in ipairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            table.insert(parts, part)
        end
    end
    
    if #parts == 0 then return end
    
    -- –°–æ—Ä—Ç–∏—Ä—É–µ–º —á–∞—Å—Ç–∏ –ø–æ Y-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–µ (—Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑)
    table.sort(parts, function(a, b)
        return a.Position.Y > b.Position.Y
    end)
    
    local maxY = parts[1].Position.Y
    local minY = parts[#parts].Position.Y
    local heightRange = maxY - minY
    
    if heightRange <= 0 then return end
    
    -- –ü—Ä–∏–º–µ–Ω—è–µ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç —Ä–∞–¥—É–≥–∏
    local timeOffset = tick() * RainbowFling.Speed
    
    for i, part in ipairs(parts) do
        local normalizedY = (part.Position.Y - minY) / heightRange
        
        -- –°–æ–∑–¥–∞–µ–º —Ä–∞–¥—É–∂–Ω—ã–π –≥—Ä–∞–¥–∏–µ–Ω—Ç —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑
        -- –î–æ–±–∞–≤–ª—è–µ–º —Å–º–µ—â–µ–Ω–∏–µ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
        local hue = (normalizedY + timeOffset + RainbowFling.RainbowOffset) % 1
        
        -- –Ø—Ä–∫–∏–µ –Ω–∞—Å—ã—â–µ–Ω–Ω—ã–µ —Ü–≤–µ—Ç–∞
        local color = Color3.fromHSV(hue, 1, 1)
        
        -- –ü—Ä–∏–º–µ–Ω—è–µ–º —Ü–≤–µ—Ç
        part.BrickColor = BrickColor.new(color)
        
        -- –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –º–µ—Ç–æ–¥ –µ—Å–ª–∏ BrickColor –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç
        if part:FindFirstChildOfClass("SurfaceAppearance") then
            local surface = part:FindFirstChildOfClass("SurfaceAppearance")
            if surface then
                surface.Color3 = color
            end
        end
    end
end

-- –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—è
local function toggleRainbowFling(state)
    RainbowFling.Enabled = state
    
    if state then
        if RainbowFling.Conn then 
            RainbowFling.Conn:Disconnect() 
        end
        
        RainbowFling.Conn = RunService.Heartbeat:Connect(function(deltaTime)
            if not RainbowFling.Enabled then return end
            
            local character = getPlayerObject()
            if not character then return end
            
            -- –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Å–º–µ—â–µ–Ω–∏–µ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ –ø–µ—Ä–µ–ª–∏–≤–∞–Ω–∏—è
            RainbowFling.RainbowOffset = (RainbowFling.RainbowOffset + deltaTime * RainbowFling.Speed) % 1
            
            applyVerticalRainbow(character)
        end)
        
        -- Notify("Rainbow Fling Tool enabled", 5)
    else
        RainbowFling.Enabled = false
        
        if RainbowFling.Conn then 
            RainbowFling.Conn:Disconnect() 
            RainbowFling.Conn = nil 
        end
        
        -- –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Ü–≤–µ—Ç–∞
        local character = getPlayerObject()
        if character then
            for _, part in ipairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    -- –ú–æ–∂–Ω–æ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Ü–≤–µ—Ç–∞ –µ—Å–ª–∏ –æ–Ω–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã
                    part.BrickColor = BrickColor.new("Medium stone grey")
                end
            end
        end
        
        -- Notify("Rainbow Fling Tool disabled", 5)
    end
end

-- –î–æ–±–∞–≤–ª—è–µ–º —Å–ª–∞–π–¥–µ—Ä –¥–ª—è —Å–∫–æ—Ä–æ—Å—Ç–∏
GameSpecificTab:Slider("Rainbow Speed", 0.1, 10, 2, function(value)
    RainbowFling.Speed = value
end)

-- –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –≤ UI
GameSpecificTab:Toggle("Rainbow Fling Tool On/Off", false, function(state)
    toggleRainbowFling(state)
end)

-- Spin speed slider
local spinSpeed = 10
GameSpecificTab:Slider("Spin Speed", 10, 1000, 100, function(value)
    spinSpeed = value
end)

-- Spin
local Spin = { Conn = nil }
GameSpecificTab:Toggle("Spin On/Off", false,function(State)
    if State then
        local p = getPlayerObject()
        if p then
            local rp = p:FindFirstChild("HumanoidRootPart")
            if rp then
                if Spin.Conn then Spin.Conn:Disconnect() end
                Spin.Conn = RunService.Heartbeat:Connect(function()
                    if rp and rp.Parent then
                        rp.CFrame = rp.CFrame * CFrame.Angles(0, math.rad(spinSpeed) * (RunService.Heartbeat and 1/60 or 1/60), 0)
                    end
                end)
            end
        end
        else
            if Spin.Conn then Spin.Conn:Disconnect() Spin.Conn = nil end
        end
    end
)

-- Giper Flinging
local walkflinging = false

local function giperWalkFling()
    if humanoid then
        humanoid.Died:Connect(function()
            walkflinging = false
        end)
    end


    repeat RunService.Heartbeat:Wait()
        local root = getRootPart()
        local vel, movel = nil, 0.1

        while not (character and character.Parent and root and root.Parent) do
            RunService.Heartbeat:Wait()
            character = getPlayerObject()
            root = getRoot(character)
        end

        vel = root.Velocity
        root.Velocity = vel * 10000 + Vector3.new(0, 10000, 0)

        RunService.RenderStepped:Wait()
        if character and character.Parent and root and root.Parent then
            root.Velocity = vel
        end

        RunService.Stepped:Wait()
        if character and character.Parent and root and root.Parent then
            root.Velocity = vel + Vector3.new(0, movel, 0)
            movel = movel * -1
        end
    until walkflinging == false
end



GameSpecificTab:Toggle("Fling On/Off", false,function(State)
    if State then
        walkflinging = State
        giperWalkFling()
    else
        walkflinging = State
        giperWalkFling()
    end
end)

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
GameSpecificTab:Label("Teleport Tools‚úà")

local function GetPlayerNames()
    local names = {}
    for _, player in pairs(game:GetService("Players"):GetPlayers()) do
        table.insert(names, player.Name)
    end
    return names
end

local function teleportToPlayer(targetPlayer)
    local player = game:GetService("Players").LocalPlayer
    local character = player.Character
    local targetCharacter = targetPlayer and targetPlayer.Character

    if character and targetCharacter then
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        local targetRootPart = targetCharacter:FindFirstChild("HumanoidRootPart")

        if rootPart and targetRootPart then
            -- –¢–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä—É–µ–º
            rootPart.CFrame = targetRootPart.CFrame + Vector3.new(0, 5, 0)
        end
    end
end

local playerList = GetPlayerNames()
local PlayerSelector = GameSpecificTab:Dropdown("Choose Player", playerList, playerList[1] or "None", function(selected)
    local target = game:GetService("Players"):FindFirstChild(selected)
    teleportToPlayer(target)
end)

local function RefreshPlayerList()
    local currentPlayers = GetPlayerNames()

    if PlayerSelector and PlayerSelector.Refresh then
        PlayerSelector:Refresh(currentPlayers)
    end
end

local Players = game:GetService("Players")
table.insert(MenooWindow.Connections, Players.PlayerAdded:Connect(function()
    task.wait(1)
    RefreshPlayerList()
end))

table.insert(MenooWindow.Connections, Players.PlayerRemoving:Connect(RefreshPlayerList))





------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MasterFuncTab:Label("‚ò¢Master Functions‚ò¢")

local LocalPlayer = Players.LocalPlayer

-- 1. –§—É–Ω–∫—Ü–∏—è —Ä–∞–¥—É–≥–∏ (–æ–±—â–∞—è –¥–ª—è –≤—Å–µ–≥–æ)
local function getRainbowColor(speed)
    local hue = (tick() * (speed or 0.5)) % 1
    return Color3.fromHSV(hue, 1, 1)
end

-- 2. –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
local AIM_SETTINGS = {
    Enabled = false,
    Key = Enum.UserInputType.MouseButton2, -- –ü—Ä–∞–≤–∞—è –∫–Ω–æ–ø–∫–∞ –º—ã—à–∏
    Part = "Head",
    Radius = 150,
    Smoothness = 0.7, -- –û—Ç 0.01 –¥–æ 1
    ShowFOV = true
}

local isPressing = false

-- 3. –°–æ–∑–¥–∞–Ω–∏–µ –∫—Ä—É–≥–∞ FOV (Drawing API)
local fovCircle = Drawing.new("Circle")
fovCircle.Thickness = 1
fovCircle.NumSides = 64
fovCircle.Filled = false
fovCircle.Transparency = 1
fovCircle.Visible = false

-- 4. –§—É–Ω–∫—Ü–∏—è –ø–æ–∏—Å–∫–∞ –±–ª–∏–∂–∞–π—à–µ–π —Ü–µ–ª–∏ –∫ –ø—Ä–∏—Ü–µ–ª—É
local function getClosestToMouse()
    local target = nil
    local dist = AIM_SETTINGS.Radius

    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local part = player.Character:FindFirstChild(AIM_SETTINGS.Part)
            local hum = player.Character:FindFirstChild("Humanoid")
            
            if part and hum and hum.Health > 0 then
                -- –ü–µ—Ä–µ–≤–æ–¥–∏–º 3D –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏–≥—Ä–æ–∫–∞ –Ω–∞ 2D —ç–∫—Ä–∞–Ω
                local screenPos, onScreen = Camera:WorldToViewportPoint(part.Position)
                
                if onScreen then
                    local mouse = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
                    local magnitude = (Vector2.new(screenPos.X, screenPos.Y) - mouse).Magnitude
                    
                    if magnitude < dist then
                        target = part
                        dist = magnitude
                    end
                end
            end
        end
    end
    return target
end

-- 5. –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è
MasterFuncTab:Toggle("Master Aim On/Off", false, function(state)
    AIM_SETTINGS.Enabled = state
    fovCircle.Visible = state and AIM_SETTINGS.ShowFOV
end)

MasterFuncTab:Slider("Aim Radius", 50, 600, 100, function(v)
    AIM_SETTINGS.Radius = v
end)

MasterFuncTab:Slider("Aim Smooth (x100)", 1, 100, 70, function(v)
    AIM_SETTINGS.Smoothness = v / 100
end)

MasterFuncTab:Dropdown("Target Part", {"Head", "UpperTorso", "HumanoidRootPart"}, "Head", function(v)
    AIM_SETTINGS.Part = v
end)

-- 6. –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤–≤–æ–¥–∞ (–ú—ã—à—å)
UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == AIM_SETTINGS.Key then
        isPressing = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == AIM_SETTINGS.Key then
        isPressing = false
    end
end)

-- 7. –ì–õ–ê–í–ù–´–ô –¶–ò–ö–õ (–û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–∂–¥—ã–π –∫–∞–¥—Ä)
RunService.RenderStepped:Connect(function()
    -- –û–±–Ω–æ–≤–ª—è–µ–º —Ä–∞–¥—É–∂–Ω—ã–π –∫—Ä—É–≥
    if fovCircle.Visible then
        fovCircle.Radius = AIM_SETTINGS.Radius
        fovCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
        fovCircle.Color = getRainbowColor(0.5)
    end

    -- –õ–æ–≥–∏–∫–∞ –Ω–∞–≤–µ–¥–µ–Ω–∏—è
    if AIM_SETTINGS.Enabled and isPressing then
        local target = getClosestToMouse()
        
        if target then
            -- –í—ã—á–∏—Å–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –≤–∑–≥–ª—è–¥–∞
            -- CFrame.new(–≥–ª–∞–∑–∞, —Ü–µ–ª—å) —Å–æ–∑–¥–∞–µ—Ç –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é, —Å–º–æ—Ç—Ä—è—â—É—é –Ω–∞ —Ü–µ–ª—å
            local lookAt = CFrame.new(Camera.CFrame.Position, target.Position)
            
            -- –ü–ª–∞–≤–Ω–æ –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –∫–∞–º–µ—Ä—É
            Camera.CFrame = Camera.CFrame:Lerp(lookAt, AIM_SETTINGS.Smoothness)
        end
    end
end)

---------------------------------------------------------TEAM CHECKER------------------------------------------------------------
-- 1. –ù–∞—Å—Ç—Ä–æ–π–∫–∏
BigHeadcfg = {
    Enabled = false,
    Scale = 20,
    Mode = "Team Mode" -- –•—Ä–∞–Ω–∏–º –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ä–µ–∂–∏–º —Ç—É—Ç
}

-- 2. –§—É–Ω–∫—Ü–∏—è —Å–±—Ä–æ—Å–∞ –≥–æ–ª–æ–≤ (—á—Ç–æ–±—ã –Ω–µ –¥—É–±–ª–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥)
local function resetAllHeads()
    for _, p in pairs(Players:GetPlayers()) do
        if p.Character and p.Character:FindFirstChild("Head") then
            local head = p.Character.Head
            head.Size = Vector3.new(1.2, 1.2, 1.2)
            head.Transparency = 0
            head.CanCollide = true
        end
    end
end

-- 3. –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è
local function toggleHitbox(state)
    BigHeadcfg.Enabled = state
    
    -- –°–Ω–∞—á–∞–ª–∞ –≤—Å–µ–≥–¥–∞ –æ—Ç–∫–ª—é—á–∞–µ–º —Å—Ç–∞—Ä–æ–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ –∏ —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –≥–æ–ª–æ–≤—ã
    if connections.Hitbox then 
        connections.Hitbox:Disconnect() 
        connections.Hitbox = nil
    end
    resetAllHeads()

    if BigHeadcfg.Enabled then
        connections.Hitbox = RunService.RenderStepped:Connect(function()
            for _, p in pairs(Players:GetPlayers()) do
                if p.UserId ~= player.UserId and p.Character and p.Character:FindFirstChild("Head") then
                    local head = p.Character.Head
                    local isEnemy = true

                    -- –ï—Å–ª–∏ –≤—ã–±—Ä–∞–Ω Team Mode, –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–º–∞–Ω–¥—É
                    if BigHeadcfg.Mode == "Team Mode" then
                        if player.Team and p.Team then
                            if p.Team == player.Team then isEnemy = false end
                        elseif player.TeamColor == p.TeamColor then
                            isEnemy = false
                        end
                    end

                    -- –ï—Å–ª–∏ —ç—Ç–æ –≤—Ä–∞–≥ (–∏–ª–∏ —Ä–µ–∂–∏–º FFA), —É–≤–µ–ª–∏—á–∏–≤–∞–µ–º
                    if isEnemy then
                        head.Size = Vector3.new(BigHeadcfg.Scale, BigHeadcfg.Scale, BigHeadcfg.Scale)
                        head.Transparency = 0.7
                        head.CanCollide = false
                        head.Massless = true
                    else
                        -- –î–ª—è —Å–æ—é–∑–Ω–∏–∫–æ–≤ –≤ Team Mode –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –Ω–æ—Ä–º—É
                        head.Size = Vector3.new(1.2, 1.2, 1.2)
                        head.Transparency = 0
                    end
                end
            end
        end)
    end
end
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
MasterFuncTab:Label("") -- –ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –¥–ª—è –æ—Ç—Å—Ç—É–ø–∞
-- 4. GUI –≠–ª–µ–º–µ–Ω—Ç—ã
MasterFuncTab:Slider("Hitbox Size", 15, 70, 20, function(value)
    BigHeadcfg.Scale = value
end)

MasterFuncTab:Dropdown("Hitbox Mode", {"FFA Mode", "Team Mode"}, "Team Mode", function(value)
    BigHeadcfg.Mode = value
    -- –ï—Å–ª–∏ —á–∏—Ç —É–∂–µ –≤–∫–ª—é—á–µ–Ω, –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º –µ–≥–æ —Å –Ω–æ–≤—ã–º —Ä–µ–∂–∏–º–æ–º –º–≥–Ω–æ–≤–µ–Ω–Ω–æ
    if BigHeadcfg.Enabled then
        toggleHitbox(true)
    end
end)

MasterFuncTab:Toggle("Hitbox Expander On/Off", false, function(state)
    toggleHitbox(state)
end)

MasterFuncTab:Button("Get Jerk Off Tool", function ()
    -- –°–æ–∑–¥–∞–µ–º –ø—Ä–µ–¥–º–µ—Ç
    local tool = Instance.new("Tool")
    tool.Name = "Jerk Stick"
    tool.RequiresHandle = true
    
    local handle = Instance.new("Part")
    handle.Name = "Handle"
    handle.Size = Vector3.new(0.5, 2, 0.5)
    handle.Parent = tool
    
    local toolScript = Instance.new("LocalScript")
    -- –í—Å—Ç–∞–≤–ª—è–µ–º –ª–æ–≥–∏–∫—É –¥–≤–∏–∂–µ–Ω–∏—è
    toolScript.Source = [[
        local tool = script.Parent
        local char = game.Players.LocalPlayer.Character
        -- –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ R6 –∏–ª–∏ R15 (–Ω–∞–∑–≤–∞–Ω–∏—è —Å—É—Å—Ç–∞–≤–æ–≤ —Ä–∞–∑–Ω—ã–µ)
        local shoulder = char:FindFirstChild("Right Shoulder", true) or char:FindFirstChild("RightShoulder", true)
        local origC0 = shoulder.C0
        local active = false

        tool.Activated:Connect(function()
            active = not active
            while active do
                -- –î–≤–∏–∂–µ–Ω–∏–µ —Ä—É–∫–∏ (CFrame –≤–∏–¥—è—Ç –≤—Å–µ)
                for i = 0, 1, 0.2 do
                    if not active then break end
                    shoulder.C0 = origC0 * CFrame.Angles(math.rad(45 + (i * 30)), 0, 0)
                    task.wait(0.03)
                end
                for i = 1, 0, -0.2 do
                    if not active then break end
                    shoulder.C0 = origC0 * CFrame.Angles(math.rad(45 + (i * 30)), 0, 0)
                    task.wait(0.03)
                end
            end
            shoulder.C0 = origC0 -- –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä—É–∫—É –≤ –Ω–æ—Ä–º—É
        end)
    ]]
    toolScript.Parent = tool
    tool.Parent = game.Players.LocalPlayer.Backpack
end)




------------------------------------------------------------------------------------------------------------------------------------------------------------------------

OtherToolsTab:Label("Other Useful Tools")

OtherToolsTab:Button("Infinite Yield", function()
        loadstring(game:HttpGet('https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source'))()
        Notify("Infinite Yield loaded", 5)
end)

OtherToolsTab:Button("Realy Dex V4", function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/peyton2465/Dex/master/out.lua"))()
        Notify("Realy Dex V4 loaded", 5)
end)

OtherToolsTab:Label("More tools will be added in future updates!")



SettingsTab:Label("Settings")

SettingsTab:Button("Copy Game Link", function()
    local placeId = game.PlaceId
    local jobId = game.JobId:split("?")[1]
    local gameLink = "https://www.roblox.com/games/" .. placeId .. "/" .. "?jobId=" .. jobId
    setclipboard(gameLink)
end, "")

SettingsTab:Button("Server Crash (may not work)", function()
    local ts = game:GetService("TeleportService")
    local p = game:GetService("Players").LocalPlayer
    ts:TeleportToPlaceInstance(game.PlaceId, "0", p)
end, "")

SettingsTab:Label("Server Tools‚õß")

SettingsTab:Button("Rejoin Server", function()
    local ts = game:GetService("TeleportService")
    local p = game:GetService("Players").LocalPlayer
    ts:Teleport(game.PlaceId, p)
end, "")

local function ServerHop()
    local HttpService = game:GetService("HttpService")
    local TeleportService = game:GetService("TeleportService")
    local Api = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Desc&limit=100"
    
    local function GetServers(cursor)
        local url = Api .. (cursor and "&cursor=" .. cursor or "")
        local success, result = pcall(function()
            return HttpService:JSONDecode(game:HttpGet(url))
        end)
        
        if success and result then
            return result
        end
        return nil
    end

    local servers = GetServers()
    if servers then
        for _, server in pairs(servers.data) do
            -- –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Å–µ—Ä–≤–µ—Ä –Ω–µ –ø–æ–ª–Ω—ã–π –∏ —ç—Ç–æ –Ω–µ –Ω–∞—à —Ç–µ–∫—É—â–∏–π —Å–µ—Ä–≤–µ—Ä
            if server.playing < server.maxPlayers and server.id ~= game.JobId then
                TeleportService:TeleportToPlaceInstance(game.PlaceId, server.id)
                return -- –ü—Ä–µ–∫—Ä–∞—â–∞–µ–º –ø–æ–∏—Å–∫, –µ—Å–ª–∏ –Ω–∞—à–ª–∏ —Å–µ—Ä–≤–µ—Ä
            end
        end
    end
    
    warn("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –ø–æ–¥—Ö–æ–¥—è—â–∏–π —Å–µ—Ä–≤–µ—Ä –¥–ª—è –ø–µ—Ä–µ—Ö–æ–¥–∞.")
end

SettingsTab:Button("Server Hop", function()
    ServerHop()
end, "")

------------------------------------------------------------------------------------------------------------------------------------------------------------------------
SettingsTab:Label("Client Tools‚öô")

SettingsTab:Button("Enable old console (PC only)", function()
    local _, str = pcall(function()
        return game:HttpGet("https://raw.githubusercontent.com/infyiff/backup/main/console.lua", true)
    end)

    local s, e = loadstring(str)
    if typeof(s) ~= "function" then
        return
    end

    local success, message = pcall(s)
    if (not success) then
            print(message)
    else
            print(message)
    end
    wait(1)
end, "")

SettingsTab:Button("Reset Character", function()
    player.Character.Humanoid.Health = 0
end, "")


local allThemes = GeminiLib:GetThemesList()
-- –¢–æ—Ç —Å–∞–º—ã–π Dropdown
SettingsTab:Dropdown("Current Theme", allThemes, currentTheme, function(value)
    MenooWindow:ChangeTheme(value)
end)


CreditsTab:Label("Menoo ".. GeminiLib:Version() .. " by ")
CreditsTab:Label("nxs_Bounty - Developer")
CreditsTab:Label("Thanks to all supporters and testers!")
CreditsTab:Label("") -- –ü—É—Å—Ç–∞—è —Å—Ç—Ä–æ–∫–∞ –¥–ª—è –æ—Ç—Å—Ç—É–ø–∞

CreditsTab:Button("Discord Server Invite (in future)", function()
    setclipboard("https://discord.gg/nxsBounty")
end, "Click to copy Discord invite link")

CreditsTab:Button("Join Roblox Group (in future)", function()
    setclipboard("https://www.roblox.com/groups/15142097")
end, "Click to copy Roblox Group link")

CreditsTab:Label("")
CreditsTab:Label("Thanks for using Menoo V6! Enjoy your time!")



------------------------------------------------------------------------------------------------------------------------
-- –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–ª–∞–≤–∞—é—â–µ–π –∫–Ω–æ–ø–∫–∏ –∏ –≥–æ—Ä—è—á–µ–π –∫–ª–∞–≤–∏—à—ã

-- –°–æ–∑–¥–∞–µ–º –ø–ª–∞–≤–∞—é—â—É—é –∫–Ω–æ–ø–∫—É –ø–æ—Å–ª–µ –Ω–µ–±–æ–ª—å—à–æ–π –∑–∞–¥–µ—Ä–∂–∫–∏
task.wait(0.5)  -- –î–∞–µ–º –≤—Ä–µ–º—è –∑–∞–≥—Ä—É–∑–∏—Ç—å—Å—è –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—É
if MenooWindow.CreateFloatingButton then
    MenooWindow:CreateFloatingButton()
end
-- –¢–∞–∫–∂–µ –¥–æ–±–∞–≤—å—Ç–µ –≥–ª–æ–±–∞–ª—å–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è –º–µ–Ω—é –ø–æ –≥–æ—Ä—è—á–µ–π –∫–ª–∞–≤–∏—à–µ
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    
    -- F5 –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è/–∑–∞–∫—Ä—ã—Ç–∏—è –º–µ–Ω—é
    if input.KeyCode == Enum.KeyCode.F5 then
        if MenooWindow.ToggleVisibility then
            MenooWindow:ToggleVisibility()
        end
    end
end)
